# Java Script Kiddie

## Background

This challenge is to decrypt a JavaScript function so that we can display a PNG file. The webpage source gives us an input field that 
displays a broken image. Looking through the webpage source code we can figure our objective is to deduce the input field stored in
the variable 'key' which will perform operations on the 'bytes' variable, ultimately displaying our PNG. The 'bytes' variable is an array of hexadecimals 
which represent the data of the PNG file we'd like to decrypt .The functions described below are performed on the 'bytes' variable. 

### Nested For Loop Purpose 

- key.charCodeAt(i) - 48: encodes representation of integer at index i to unicode, then subtracts 48 to change data type to integer.

### Inner Loop

- iterate while less than the length of bytes variable / LEN variable (16). This splits the bytes into blocks of data to be processed
- add encoded character to index j, then multiply by LEN (16) and % lenght of byes, then add index i
- store result into array with key being index j multiplied by LEN (16) then add index i

This inner loops maps an index of the result variable to an index of the bytes array. Using this map we must use our known bytes array
to deduce the transformation to the result array.

### End Condition  

- Splice all of the trailing zeros from array

### End of Script 

- Loads "Area" image which is stored in base64. This will fail if the key is incorrect


## Solution


### Decrypting The JavaScript

Our objective is to figure out the key by using the transformation made on the bytes array. We want the index of the resulting array to
map in a way that will output a valid image. Currently our image returns broken because the mapping doesn't match the standard structure
of a PNG image. the PNG image must follow the structure:

---
	| Hex | Characters | 
	|89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52|.PNG........IHDR|
	|00 00 00 01 00 00 00 01 08 02 00 00 00 90 77 53|..............wS|
	|DE 00 00 00 0C 49 44 41 54 08 D7 63 F8 CF C0 00|.....IDAT..c....|
	|00 03 01 01 00 18 DD 8D B0 00 00 00 00 49 45 4E|.............IEN|
	|44 AE 42 60 82|AD.B`.|

---

Using the first 16 bytes of the png structure we can figure out the original key by attempting to map the resulting index to our format. 
By matching the first 16 bytes in the PNG structure and the resulting index of our function: 

```
index_result = (j * 16) + i
```

We have a relation between our original index without the key and our destined index of the png structure. The variable 'j' points to the current block
and the variable 'i' is the ~i~th element of the key. Our key has a range of 0-9 so we can set j to loop from 0-9. If the result matches the PNG format, 
then that j is the desired shift and we set it to the ~i~th element of the key. This explanation can be more intuitively understood by looking at a binary 
representation of our byte's array, and searching in each column, what shift 'j' is necessary to map to the PNG format. ![Binary Bytes File][hexedit.png]


### Obtaining The Flag

After completing a [script][unscramble.py] that shifts from 0-9 and stores the shift if it matches the png format we're nearly done with the challenge. There
is only one step left. In the first 16 bytes of the png format there are some 00 values, which return multiple possibilities for the shifts. ![Shift Possibilities][keypermuation.png]  

With the possible shifts for those three indexes we can brute-force the rest of the key. There are 3 * 4 * 3 total possibilities which result in 34 attempts. After
inputting the correct key into the input field a QR code is displayed. Decoding the qrcode returns the flag for this challenge. ![QR Code][flag.png]
